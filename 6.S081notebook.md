# 6.S081notebook

## xv6

pull  gbhttps://hub.docker.com/r/kortanzh/xv6

我的实验步骤

```bash
docker run -itd -v /d/PycharmProjects:/work -e BUILDER_UID=123 -e BUILDER_GID=456 --name container_name kortanzh/xv6 bash  
返回 : 2fe47549fa9131f569a409e8f29c03a929ac1212e35bee0d68a5ad70411742ca
我再 docker exec -it --user 123 container_name bash 
显示[adam@2fe47549fa91 work]$ 
```

他装好了git, 装好了qemu-system-riscv64 --version

**Do not use `exit` to quit if you are half done your jobs, use `ctrl-p ctrl-q` to detach from the container.**



别人的笔记

https://github.com/silvermagic/xv6-labs-2020



## guidance

尽管大多数 C 程序从来不需要在指针和整数之间转换，但操作系统经常这样做。每当您看到涉及内存地址的添加时，询问自己是整数添加还是指针添加，并确保要添加的值是否适当相乘。

- 如果练习部分工作，请通过提交代码来检查进度。如果以后中断了某样东西，可以回滚到检查点，然后以较小的步骤前进。
- 如果测试失败，请确保了解代码失败的原因。插入打印语句，直到了解发生了什么。
- 您可能会发现，您的打印语句可能会产生许多输出，您想搜索;一种方法就是 `make qemu` inside of script，该脚本将所有控制台输出记录到一个文件中，然后您可以搜索该文件。别忘了退出脚本。
- 在许多情况下，打印语句就足够了，但有时能够单步调试 汇编代码或检查堆栈上的变量是有帮助的。若要将 gdb 与 xv6 一起使用，请在另一个窗口中运行 `make qemu-gdb`，在另一个窗口中运行`gdb`或 `riscv64-linux-gnu-gdb`，设置断点，后跟"c"（继续），xv6 将运行到断点。（有关[有用的 GDB 提示，请参阅](https://pdos.csail.mit.edu/6.828/2019/lec/gdb_slides.pdf)使用 GNU 调试器。
- 如果要查看编译器为内核生成的程序集，或者要了解特定内核地址的指令，请参阅 Makefile 在编译内核时生成的文件`kernel.asm`。（Makefile 还为所有用户程序生成 `.asm`。
- 如果内核panics死机，它会打印一条错误消息，列出程序计数器崩溃时的值;如果内核死机，它将打印一条错误消息，列出程序计数器在崩溃时的值。您可以搜索`kernel.asm`以找出程序计数器崩溃时在哪个函数中，也可以运行`addr2line -e kernel/kernel pc-value`（运行`man addr2line`详细信息）。如果要回溯，请使用 gdb 重新启动：在一个窗口中运行`make qemu-gdb`，在另一个窗口中运行 gdb（或 riscv64-linux-gnu-gdb），在panic中设置断点（"b panic"），后跟"c"（继续）。当内核到达断点时，键入"bt"以获得回溯。
- 如果您的内核挂起（例如，由于死锁）或无法进一步执行（例如，由于执行内核指令时由于页面错误page fault），您可以使用 gdb 来找出它的挂起位置。在一个窗口中运行"make qemu-gdb"，在另一个窗口中运行 gdb （riscv64-linux-gnu-gdb），后跟"c"（继续）。当内核似乎挂起时，在 qemu-gdb 窗口中点击 Ctrl-C 并键入"bt"以获得回溯backtrace。
- `qemu`具有一个"监视器"，允许您查询模拟计算机的状态。您可以通过键入 control - a c 来获取它（"c"用于控制台console）。一个特别有用的监视器命令是`info mem`用于打印页表的信息。您可能需要使用 `cpu` 命令来选择`info mem`查看哪个core的信息，或者您可以使用`make CPUS=1 qemu` 使只有一个内核。



## lab1

```bash
git clone git://g.csail.mit.edu/xv6-labs-2020
```

太慢了, 只有8kb , 我用了GitHub别人的代码库, 可以56kb, 快7倍. 大概用了5分钟?  

但是该怎么提交到我的代码库? 

我想了一下, 你把他的git删除, 然后自己在外层设置仓库试一试. 

其实你已经镜像到D:\PycharmProjects\xv6-labs-2020 , 那直接拖到仓库就可以了.

```bash
make qemu
```

启动xv6 内核

ls 可以显示这个机器里的东西.

xv6 has no `ps` command, but, if you type Ctrl-p(在docker中不能正常运行,会detach), the kernel will print information about each process. If you try it now, you'll see two lines: one for `init`, and one for `sh`.

To quit qemu type: Ctrl-a 然后按下x.  这在docker中也可以正常运行  

#### 系统调用

```c
pid = fork();// 获得新process的id--- process identification
read(0,buf,sizeof(buf));
int fd =  open("output.txt",O_WRONLY | O_CREATE);// 获得一个file descripter告诉内核创建一个文件,  然后写入,返回fd
```

read 第一个参数是系统调用, 对之前打开的文件的引用. shell启动时默认把文件描述符0 连接到控制台输入.把文件描述符1 连接到控制台输出.这是unix的约定.buf 是一个指向memory的指针,在栈内存上, 读取data. 按下回车时就清空. 

如果第三个参数你传入的是sizeof(buf)+1, 操作系统就会复制这么多, 会把buf之外stack上其他东西复制进去.

read也可以用来读文件,到文件结尾, 那就返回0 . 文件描述符不存在, 返回-1.

应该要检查所有的系统调用的返回是否有错误.

书中11页写了所有系统调用参数和返回值.

open, 创建文本描述符是open.c 调用open 

文本描述符(fd) 实际上做的是: 索引到内核中一个维护进程状态的表中, 这张表告诉内核每个文件描述符 引用的是什么.  内核为每个进程维护单独的fd. 所以 同样的fd在不同进程中可能引用不同文件.



特殊的 riscv 指令ecall  程序可以调用ecall将控制权转到内核.





#### fork &wait system call

wait system call是啥? 下面这个代码跨了一个figure导致我看半天看不出来

```c
int pid = fork();
if(pid > 0){
	printf("parent: child=%d\n", pid);
    pid = wait((int *) 0);//这里会等待子进程返回 The wait system call returns the PID of an exited (or killed) child of the current process and copies the exit status of the child to the address passed to wait; if none of the caller’s children has exited, 就等 one to do so. If the caller没子process, wait立刻返回-1. If the parent不关心the exit status of a child, it can pass a 0 address to wait.
	printf("child %d is done\n", pid);
} else if(pid == 0){
	printf("child: exiting\n");
	exit(0);//The exit system call causes the calling process to stop executing and to release resources such as memory and open files. Exit takes an integer status argument, conventionally 0 to indicate success and 1 to indicate failure.
} else {
	`printf("fork error\n");
}
```

After the child exits, the parent’s wait returns, causing the parent to print 

`parent: child 1234 is done`

#### exec

```bash
char *argv[3];
argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
```

其实main本质上是一个脚本, loop不断用getcmd 函数来读入,   

vim打开sh.c, 输入143 再回车就可以进入143行. 

```c
   if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
      // Chdir must be called by the parent, not the child.
```

是这么解析的, 这也就是为什么我们cd后面要加个空格,不然就不能识别.

但是他为啥要fork,The parent calls wait, while the child runs the command. 但是他为啥要fork呢?

#### sleep

cmd结构中是一个int type

echo.c 调用了write , write函数在哪里我为啥找不到? 哦好像找到了, 在user/usys.S 中.

rm.c 的本质是unlink

how you can obtain the command-line arguments passed to a program?

答: `int main(int argc, char *argv[])`

- If the user forgets to pass an argument, sleep should print an error message.

可以用atoi

要调用sys_sleep,user/usys.S 这里找到汇编跳入sleep



```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"



int
main(int argc, char *argv[])
{
  int i;

  for(i = 1; i < argc; i++){
    write(1, argv[i], strlen(argv[i]));
    if(i + 1 < argc){
      write(1, " ", 1);
    } else {
      write(1, "\n", 1);
    }
  }
  exit(0);
}



```

